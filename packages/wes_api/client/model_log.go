/*
 * Workflow Execution Service
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package wes_client

import (
	"encoding/json"
	"fmt"
)

// Log - Log and other info
type Log struct {

	// The task or workflow name
	Name string `json:"name,omitempty"`

	// The command line that was executed
	Cmd []string `json:"cmd,omitempty"`

	// When the command started executing, in ISO 8601 format \"%Y-%m-%dT%H:%M:%SZ\"
	StartTime string `json:"start_time,omitempty"`

	// When the command stopped executing (completed, failed, or cancelled), in ISO 8601 format \"%Y-%m-%dT%H:%M:%SZ\"
	EndTime string `json:"end_time,omitempty"`

	// A URL to retrieve standard output logs of the workflow run or task.  This URL may change between status requests, or may not be available until the task or workflow has finished execution.  Should be available using the same credentials used to access the WES endpoint.
	Stdout string `json:"stdout,omitempty"`

	// A URL to retrieve standard error logs of the workflow run or task.  This URL may change between status requests, or may not be available until the task or workflow has finished execution.  Should be available using the same credentials used to access the WES endpoint.
	Stderr string `json:"stderr,omitempty"`

	// Exit code of the program
	ExitCode string `json:"exit_code,omitempty"`
}

// WES servers are supposed to send exit codes as ints, but some AGC adapters
// actually send them as quoted strings in JSON. We need to handle either.
func (self *Log) UnmarshalJSON(data []byte) error {
	// Use a couple levels of type wrapping to let us use the default
	// implementation for everything except the field that needs custom logic.
	// See <https://stackoverflow.com/a/62992367>.

	type LogFields Log
	var unmarshallTo struct {
		// This will get exit_code over the composed-in field
		ExitCodeJSON json.RawMessage `json:"exit_code,omitempty"`
		LogFields
	}
	// Unmarshall everything that's easy
	err := json.Unmarshal(data, &unmarshallTo)
	if err != nil {
		// We can't even parse the rest of the info.
		// Still need to move what we can into us.
		*self = Log(unmarshallTo.LogFields)
		return err
	}

	if len(unmarshallTo.ExitCodeJSON) > 0 {
		// An exit code is present.
		// We need to parse the exit code.
		err = json.Unmarshal(unmarshallTo.ExitCodeJSON, &unmarshallTo.ExitCode)
		if err != nil {
			// It can't be parsed as a (nullable) string. Must be an unquoted int.
			var intCode int
			err = json.Unmarshal(unmarshallTo.ExitCodeJSON, &intCode)
			if err != nil {
				// Can't parse this at all.
				// Still need to move what we can into us.
				*self = Log(unmarshallTo.LogFields)
				return err
			}
			// Convert to a string
			unmarshallTo.ExitCode = fmt.Sprintf("%d", intCode)
		}
	}

	// Move all the data back into us
	*self = Log(unmarshallTo.LogFields)
	return nil
}
